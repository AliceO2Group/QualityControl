
QCDB
---

<!--TOC generated with https://github.com/ekalinin/github-markdown-toc-->
<!--./gh-md-toc --insert --no-backup --hide-footer --indent 3 QualityControl/doc/Advanced.md -->
<!--ts-->
   * [QCDB vs CCDB](#qcdb-vs-ccdb)
   * [Details on the data storage format in the QCDB](#details-on-the-data-storage-format-in-the-qcdb)
   * [Custom metadata for QC objects in the QCDB](#custom-metadata-for-qc-objects-in-the-qcdb)
   * [Instructions to move an object in the QCDB](#instructions-to-move-an-object-in-the-qcdb)
   * [Accessing objects in CCDB](#accessing-objects-in-ccdb)
   * [Access GRP objects with GRP Geom Helper](#access-grp-objects-with-grp-geom-helper)
   * [Global Tracking Data Request helper](#global-tracking-data-request-helper)
   * [Local CCDB setup](#local-ccdb-setup)
<!--te-->

## QCDB vs CCDB

The MonitorObjects generated by Quality Control are stored in a dedicated repository called **QCDB**.
The run conditions, on the other hand, are located in another, separate database, called **CCDB**.

Both are based on a technology called _CCDB_ which does not help with the confusion...

## Details on the data storage format in the QCDB

Each MonitorObject is stored as a TFile in the QCDB.
It is therefore possible to easily open it with ROOT when loaded with alienv. It also seamlessly supports class schema evolution.

The MonitorObjects are stored at a path which is enforced by the qc framework : `/qc/<detector code>/MO/<task name>/object/name`
Note that the name of the object can contain slashes (`/`) in order to build a sub-tree visible in the GUI.
The detector name and the taskname are set in the config file :

```json
"tasks": {
  "QcTask": {       <---------- task name
    "active": "true",
    "className": "o2::quality_control_modules::skeleton::SkeletonTask",
    "moduleName": "QcSkeleton",
    "detectorName": "TST",       <---------- detector name
```

The quality is stored as a CCDB metadata of the object.

## Custom metadata for QC objects in the QCDB

One can add custom metadata on the QC objects produced in a QC task.
Simply call `ObjectsManager::addMetadata(...)`, like in

```
  // add a metadata on histogram mHistogram, key is "custom" and value "34"
  getObjectsManager()->addMetadata(mHistogram->GetName(), "custom", "34");
```

This metadata will end up in the _QCDB_.

It is also possible to add or update metadata of a MonitorObject directly:

```
  MonitorObject* mo = getMonitorObject(objectName);
  mo->addOrUpdateMetadata(key, value);
```

## Instructions to move an object in the QCDB

The script `o2-qc-repo-move-objects` lets the user move an object, and thus all the versions attached to it. E.g.:

```
python3 o2-qc-repo-move-objects --url http://ccdb-test.cern.ch:8080 --path qc/TST/MO/Bob --new-path qc/TST/MO/Bob2 --log-level 10 
```

## Accessing objects in CCDB

The recommended way (excluding postprocessing) to access the run conditions in the _CCDB_ is to use a `Lifetime::Condition` DPL input, which can be requested as in the query below:

```json
  "tasks": {
    "MyTask": {
    ...
      "dataSource": {
        "type": "direct",
        "query": "randomcluster:MFT/COMPCLUSTERS/0;cldict:MFT/CLUSDICT/0?lifetime=condition&ccdb-path=MFT/Calib/ClusterDictionary"
      },
    }
  },
```

The timestamp of the _CCDB_ object will be aligned with the data timestamp.

If a task needs both sampled input and a _CCDB_ object, it is advised to use two data sources as such:

```json
  "tasks": {
    "MyTask": {
    ...
      "dataSources": [{
        "type": "dataSamplingPolicy",
        "name": "mftclusters"
      }, {
        "type": "direct",
        "query": "cldict:MFT/CLUSDICT/0?lifetime=condition&ccdb-path=MFT/Calib/ClusterDictionary"
      }],
    }
  },
```

The requested _CCDB_ object can be accessed like any other DPL input in `monitorData`:

```
void QcMFTClusterTask::monitorData(o2::framework::ProcessingContext& ctx)
{
...
    auto mDictPtr = ctx.inputs().get<o2::itsmft::TopologyDictionary*>("cldict");
```

Geometry and General Run Parameters (GRP) can be also accessed with the [GRP Geom Helper](#access-grp-objects-with-grp-geom-helper).

If your task accesses _CCDB_ objects using `UserCodeInterface::retrieveConditionAny`, please migrate to using one of the methods mentioned above.

### Accessing from a Postprocessing task

PostProcessingTasks do not take DPL inputs, so in this case `ConditionAccess::retrieveConditionAny` should be used (it's inherited by `PostProcessingInterface` and any children).

## Access GRP objects with GRP Geom Helper

To get GRP objects via a central facility, add the following structure to the task definition and set its values
according to the needs.

```json
      "myTask": {
        ...
        "grpGeomRequest" : {
          "geomRequest": "None",     "": "Available options are \"None\", \"Aligned\", \"Ideal\", \"Alignements\"",
          "askGRPECS": "false",
          "askGRPLHCIF": "false",
          "askGRPMagField": "false",
          "askMatLUT": "false",
          "askTime": "false",
          "askOnceAllButField": "false",
          "needPropagatorD":  "false"
        }
      }
```

The requested objects will be available via [`GRPGeomHelper::instance()`](https://github.com/AliceO2Group/AliceO2/blob/dev/Detectors/Base/include/DetectorsBase/GRPGeomHelper.h) singleton.

## Global Tracking Data Request helper

To retrieve tracks and clusters for specific detectors or detector combinations, one can use the [`DataRequest`](https://github.com/AliceO2Group/AliceO2/blob/dev/DataFormats/Detectors/GlobalTracking/include/DataFormatsGlobalTracking/RecoContainer.h) helper.
By adding the following structure to a QC task, the corresponding `InputSpecs` will be automatically added to the task.

```json
      "myTask": {
        ...
        "globalTrackingDataRequest": {
            "canProcessTracks" : "ITS,ITS-TPC",
            "requestTracks" : "ITS,TPC-TRD",
            "canProcessClusters" : "TPC",
            "requestClusters" : "TPC",
            "mc" : "false"
        }
      }
```

Then, the corresponding tracks and clusters can be retrieved in the code using `RecoContainer`:

```c++
void MyTask::monitorData(o2::framework::ProcessingContext& ctx)
{
  o2::globaltracking::RecoContainer recoData;
  if (auto dataRequest = getGlobalTrackingDataRequest()) {
    recoData.collectData(ctx, *dataRequest);
  }
}
```

## Local CCDB setup

Having a central ccdb for test (ccdb-test) is handy but also means that everyone can access, modify or delete the data. If you prefer to have a local instance of the CCDB, for example in your lab or on your development machine, follow these instructions.

1. Download the local repository service from <http://alimonitor.cern.ch/download/local.jar>

2. The service can simply be run with
   `java -jar local.jar`

It will start listening by default on port 8080. This can be changed either with the java parameter “tomcat.port” or with the environment variable “TOMCAT_PORT”. Similarly the default listening address is 127.0.0.1 and it can be changed with the java parameter “tomcat.address” or with the environment variable “TOMCAT_ADDRESS” to something else (for example ‘*’ to listen on all interfaces).

By default the local repository is located in /tmp/QC (or java.io.tmpdir/QC to be more precise). You can change this location in a similar way by setting the java parameter “file.repository.location” or the environment variable “FILE_REPOSITORY_LOCATION”.

The address of the CCDB will have to be updated in the Tasks config file.

At the moment, the description of the REST api can be found in this document : <https://docs.google.com/presentation/d/1PJ0CVW7QHgnFzi0LELc06V82LFGPgmG3vsmmuurPnUg>


---

[← Go back to Configuration](Configuration.md) | [↑ Go to the Table of Content ↑](../README.md) | [Continue to FLP Suite →](FLPsuite.md)

